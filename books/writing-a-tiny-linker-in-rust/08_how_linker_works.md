---
title: "リンク処理の仕組み"
---

本章では、リンク処理の全体フローを解説する。実装に入る前に、リンカーが何をしているのかを理解しておく。

## リンク処理の全体フロー

リンカーは次の処理を順番に行う。

1. **ELFヘッダーの解析** - ファイル内のセクションヘッダーの読み取り開始位置などを取得
2. **セクションヘッダー情報の取得** - 各セクションの位置、サイズ、属性を取得
3. **各種セクション情報の取得** - シンボルテーブル、再配置情報などを取得
4. **シンボル解決** - 未定義シンボルと定義済みシンボルを紐付け
5. **セクションの結合と配置** - `.text`と`.data`を結合し、メモリアドレスを決定
6. **再配置の適用** - シンボル参照先アドレスを実際のアドレスに書き換え
7. **ELF出力** - ELFヘッダー、セクション、セクションヘッダーをファイルに書き出し

## リンク処理の全体像

コードで表現すると次のようになる。

```rust
pub fn link_to_file(&mut self, inputs: Vec<Vec<u8>>) -> Result<Vec<u8>, Error> {
    // 1. 入力ファイルをパース
    for input in inputs {
        let obj = parser::parse_elf(&input)?.1;
        self.objects.push(obj);
    }

    // 2. シンボル解決
    let mut resolved_symbols = self.resolve_symbols()?;

    // 3. セクション配置
    let (output_sections, section_name_offsets) =
        self.layout_sections(&mut resolved_symbols)?;

    // 4. 実行可能ファイルの書き出し
    let mut out = std::io::Cursor::new(Vec::new());
    self.write_executable(
        &mut out,
        resolved_symbols,
        output_sections,
        section_name_offsets,
    )?;

    Ok(out.into_inner())
}
```

## 出力されるセクション構成

最終的に生成される実行可能ファイルのセクション構成は次のようになる。

```sh
$ readelf -S a.out
There are 6 section headers, starting at offset 0x1e0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000400100  00000100
       0000000000000010  0000000000000000  AX       0     0     4
  [ 2] .data             PROGBITS         0000000000410110  00000110
       0000000000000004  0000000000000000  WA       0     0     4
  [ 3] .symtab           SYMTAB           0000000000000000  00000128
       0000000000000090  0000000000000018           4     4     8
  [ 4] .strtab           STRTAB           0000000000000000  00000111
       0000000000000011  0000000000000000           0     0     1
  [ 5] .shstrtab         STRTAB           0000000000000000  000001b8
       0000000000000027  0000000000000000           0     0     1
```

- **NULL** - インデックス0は常に空のセクション
- **.text** - 結合されたコードセクション（アドレス0x400100）
- **.data** - 結合されたデータセクション（アドレス0x410110）
- **.symtab** - 生成されたシンボルテーブル
- **.strtab** - シンボル名の文字列テーブル
- **.shstrtab** - セクション名の文字列テーブル

## メモリレイアウト

実行可能ファイルのメモリレイアウトは次のようになる。

```
アドレス空間
┌─────────────────┬──────────────┐
│ 0x000000        │ 予約領域     │
├─────────────────┼──────────────┤
│ 0x400000        │ ELFヘッダー  │  ベースアドレス
├─────────────────┼──────────────┤
│ 0x400040        │ プログラム   │
│                 │ ヘッダー     │
├─────────────────┼──────────────┤
│ 0x400100        │ .text        │  コードセクション
│                 │ (実行可能)   │
├─────────────────┼──────────────┤
│ 0x410110        │ .data        │  データセクション
│                 │ (読み書き)   │  0x10000のギャップ
└─────────────────┴──────────────┘
```

ベースアドレスは`0x400000`で、これはLinuxの標準的な実行可能ファイルのベースアドレスである。

`.text`と`.data`の間には`0x10000`（64KB）のギャップを設けている。
これは、コードセクションとデータセクションが異なるメモリ保護属性を持つため、ページ境界で分離するためである。

## シンボル解決の概要

シンボル解決では、次の処理を行う。

1. すべてのオブジェクトファイルからシンボルを収集
2. 同名シンボルの解決（未定義→定義済み、バインディングの強さで判断）
3. 重複定義のエラーチェック
4. 未解決シンボルのエラーチェック

例えば、`main.o`の未定義シンボル`x`は、`sub.o`の定義済みシンボル`x`と紐付けられる。

## セクション配置の概要

セクション配置では、次の処理を行う。

1. 各オブジェクトファイルの`.text`セクションを結合
2. 各オブジェクトファイルの`.data`セクションを結合
3. 結合後のセクションにメモリアドレスを割り当て
4. シンボルのアドレスを更新

## 再配置の概要

再配置では、次の処理を行う。

1. 各再配置エントリを処理
2. 参照先シンボルのアドレスを取得
3. 命令のアドレスと参照先アドレスから相対アドレスを計算
4. 命令の即値フィールドを書き換え

次章から、これらの処理を1つずつ実装していく。
